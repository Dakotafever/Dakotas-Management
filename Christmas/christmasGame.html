<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Decorate the Christmas Tree!</title>

<style>
  body, html {
    margin: 0;
    padding: 0;
    overflow: hidden;
    width: 100%;
    height: 100%;
    font-family: 'Orbitron', sans-serif;
    background: linear-gradient(to bottom, #1a1a1a, #0a0a0a);
  }

  #musicToggle {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 9999;
    padding: 10px 15px;
    border: none;
    border-radius: 8px;
    background: #00cc55;
    color: black;
    font-weight: bold;
    cursor: pointer;
  }

  @keyframes snowFall {
    0% { transform: translateY(-10px); }
    100% { transform: translateY(110vh); }
  }
  @keyframes sway {
    0% { transform: translateX(0); }
    100% { transform: translateX(50px); }
  }
  .snowflake {
    position: fixed;
    top: 0;
    color: white;
    pointer-events: none;
    z-index: 9999;
    font-size: 12px;
    opacity: 0.8;
    animation-name: snowFall, sway;
    animation-timing-function: linear, ease-in-out;
    animation-iteration-count: 1, infinite;
    animation-fill-mode: forwards;
  }
</style>
</head>

<body>
<button id="musicToggle">ðŸ”Š Pause</button>
<audio id="bgMusic" src="christmas-music.mp3" autoplay loop></audio>
<canvas id="gameCanvas"></canvas>

<!-- USE MODULE SCRIPT FOR THREE.JS -->
<script type="module">

  /* ================================
     IMPORT THREE.JS MODULES
     ================================ */
  import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
  import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";
  import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";

  /* ================================
     MUSIC
     ================================ */
  const music = document.getElementById("bgMusic");
  const toggle = document.getElementById("musicToggle");
  let playing = true;
  music.volume = 0.5;

  toggle.onclick = () => {
    if (playing) { music.pause(); toggle.textContent = "ðŸ”ˆ Play"; }
    else { music.play(); toggle.textContent = "ðŸ”Š Pause"; }
    playing = !playing;
  };

  /* ================================
     THREE.JS SCENE
     ================================ */
  const canvas = document.getElementById("gameCanvas");
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a0a0a);

  const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 2, 5);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // Lights
  scene.add(new THREE.AmbientLight(0xffffff, 0.7));

  const spot = new THREE.SpotLight(0xffffff, 1);
  spot.position.set(5, 10, 5);
  scene.add(spot);

  /* ================================
     LOAD CHRISTMAS TREE
     ================================ */
  const loader = new GLTFLoader();
  let tree;

  loader.load("christmas_tree.glb", (gltf) => {
    tree = gltf.scene;
    tree.scale.set(1.5, 1.5, 1.5);
    scene.add(tree);
  });

  /* ================================
     ORNAMENTS
     ================================ */
  const ornamentGroup = new THREE.Group();
  scene.add(ornamentGroup);

  const ornamentGeo = new THREE.SphereGeometry(0.08, 16, 16);

  function addOrnament(x, y, z) {
    const mat = new THREE.MeshStandardMaterial({
      color: Math.random() * 0xffffff,
      metalness: 0.8,
      roughness: 0.3
    });

    const ornament = new THREE.Mesh(ornamentGeo, mat);
    ornament.position.set(x, y, z);
    ornamentGroup.add(ornament);
  }

  /* ================================
     DRAG + PLACE ORNAMENTS
     ================================ */
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  let selected = null;

  function pointerDown(ev) {
    mouse.x = (ev.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(ev.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const hit = raycaster.intersectObjects(ornamentGroup.children);

    if (hit.length > 0) {
      selected = hit[0].object;
      return;
    }

    // Add new ornament
    const angle = Math.random() * Math.PI * 2;
    const radius = 0.7;
    const x = Math.cos(angle) * radius;
    const z = Math.sin(angle) * radius;
    const y = Math.random() * 2 + 0.4;

    addOrnament(x, y, z);
  }

  function pointerMove(ev) {
    if (!selected) return;

    mouse.x = (ev.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(ev.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
    const point = new THREE.Vector3();
    raycaster.ray.intersectPlane(plane, point);

    selected.position.x = point.x;
    selected.position.y = point.y;
  }

  function pointerUp() {
    selected = null;
  }

  window.addEventListener("pointerdown", pointerDown);
  window.addEventListener("pointermove", pointerMove);
  window.addEventListener("pointerup", pointerUp);

  /* ================================
     SNOW
     ================================ */
  function createSnowflake() {
    const flake = document.createElement("div");
    flake.className = "snowflake";
    flake.innerText = "â„";
    flake.style.left = Math.random() * window.innerWidth + "px";
    flake.style.fontSize = Math.random() * 10 + 10 + "px";
    flake.style.animationDuration = Math.random() * 10 + 10 + "s";

    document.body.appendChild(flake);
    setTimeout(() => flake.remove(), 16000);
  }

  setInterval(createSnowflake, 200);

  /* ================================
     RENDER LOOP
     ================================ */
  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  // Resize
  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

</script>
</body>
</html>
