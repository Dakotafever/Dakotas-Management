<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Haunted Maze â€” Infinite Maze with Assets</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body { margin: 0; height: 100%; background: #000; overflow: hidden; font-family: system-ui, sans-serif; color: #fff; }
    #babylon-canvas { width: 100vw; height: 100vh; display: block; }
  </style>
</head>
<body>
  <canvas id="babylon-canvas"></canvas>

  <!-- scripts -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script>
    // Infinite maze with assets and optimizations
    (() => {
      console.log('[DEBUG] Initializing optimized infinite maze...');
      const canvas = document.getElementById('babylon-canvas');
      const engine = new BABYLON.Engine(canvas, true);
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color3(0, 0, 0);

      const camera = new BABYLON.UniversalCamera("camera", new BABYLON.Vector3(50, 1.7, 50), scene);
      camera.setTarget(new BABYLON.Vector3(0, 0, 1));
      camera.attachControl(canvas, true);

      const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

      const chunkSize = 100;
      let chunks = {};
      let exitChunk = null;
      let decorMeshes = [];

      function generateChunk(chunkX, chunkZ) {
        const key = `${chunkX},${chunkZ}`;
        if (chunks[key]) return;
        console.log(`[DEBUG] Generating chunk at (${chunkX}, ${chunkZ})`);
        const cells = Array.from({length: chunkSize}, () => Array.from({length: chunkSize}, () => Math.random() < 0.3 ? 0 : 1)); // More open (30% walls)
        function carve(x,y) {
          const dirs = [[1,0],[-1,0],[0,1],[0,-1]].sort(() => Math.random()-0.5);
          for (let [dx,dy] of dirs) {
            const nx = x+dx*2, ny=y+dy*2;
            if(ny>=0 && ny<chunkSize && nx>=0 && nx<chunkSize && cells[ny][nx]===1){
              cells[y+dy][x+dx]=0; cells[ny][nx]=0;
              carve(nx,ny);
            }
          }
        }
        cells[1][1]=0; carve(1,1);
        chunks[key] = { cells, meshes: [] };

        if (!exitChunk && Math.random() < 0.05) { // Less frequent exit
          exitChunk = key;
          cells[chunkSize - 2][chunkSize - 2] = 2;
          console.log(`[DEBUG] Exit placed in chunk ${key}`);
        }

        const offsetX = chunkX * chunkSize;
        const offsetZ = chunkZ * chunkSize;
        for(let r=0;r<chunkSize;r++){
          for(let c=0;c<chunkSize;c++){
            if(cells[r][c]===1){
              const box = BABYLON.MeshBuilder.CreateBox("wall", {width:1, height:2.4, depth:1}, scene);
              box.position = new BABYLON.Vector3(offsetX + c + 0.5, 1.2, offsetZ + r + 0.5);
              const wallMat = new BABYLON.StandardMaterial("wallMat", scene);
              wallMat.diffuseColor = new BABYLON.Color3(0.13, 0.13, 0.13);
              wallMat.backFaceCulling = true; // Fix see-through walls
              box.material = wallMat;
              chunks[key].meshes.push(box);
            } else if(cells[r][c]===2){
              const exit = BABYLON.MeshBuilder.CreateBox("exit", {width:1, height:1, depth:1}, scene);
              exit.position = new BABYLON.Vector3(offsetX + c + 0.5, 0.5, offsetZ + r + 0.5);
              const exitMat = new BABYLON.StandardMaterial("exitMat", scene);
              exitMat.diffuseColor = new BABYLON.Color3(0, 1, 0);
              exit.material = exitMat;
              chunks[key].meshes.push(exit);
            }
          }
        }

        // Add decor (limited to avoid lag)
        for(let i=0;i<5;i++){ // Fewer decor per chunk
          const r = Math.floor(Math.random()*chunkSize);
          const c = Math.floor(Math.random()*chunkSize);
          if(cells[r][c]===0){
            const plane = BABYLON.MeshBuilder.CreatePlane("decor", {width:0.7, height:0.7}, scene);
            plane.position = new BABYLON.Vector3(offsetX + c + 0.5, 1.2, offsetZ + r + 0.5);
            const mat = new BABYLON.StandardMaterial("decorMat", scene);
            // Try to load texture, fallback to red
            const tex = new BABYLON.Texture('assets/decor1.png', scene);
            tex.onLoadObservable.add(() => mat.diffuseTexture = tex);
            tex.onErrorObservable.add(() => mat.diffuseColor = new BABYLON.Color3(1, 0, 0));
            plane.material = mat;
            decorMeshes.push(plane);
            chunks[key].meshes.push(plane);
          }
        }
      }

      function unloadDistantChunks() {
        const chunkX = Math.floor(camera.position.x / chunkSize);
        const chunkZ = Math.floor(camera.position.z / chunkSize);
        for (const key in chunks) {
          const [cx, cz] = key.split(',').map(Number);
          if (Math.abs(cx - chunkX) > 2 || Math.abs(cz - chunkZ) > 2) {
            chunks[key].meshes.forEach(mesh => mesh.dispose());
            delete chunks[key];
          }
        }
      }

      function checkChunks() {
        const chunkX = Math.floor(camera.position.x / chunkSize);
        const chunkZ = Math.floor(camera.position.z / chunkSize);
        for (let dx = -1; dx <= 1; dx++) {
          for (let dz = -1; dz <= 1; dz++) {
            generateChunk(chunkX + dx, chunkZ + dz);
          }
        }
        unloadDistantChunks();
      }

      function isWallAt(mx, my, chunkX, chunkZ) {
        const key = `${chunkX},${chunkZ}`;
        if (!chunks[key]) return true;
        const cells = chunks[key].cells;
        if (mx < 0 || my < 0 || mx >= chunkSize || my >= chunkSize) return true;
        return cells[Math.floor(my)][Math.floor(mx)] === 1;
      }
      function collidesAt(x, y) {
        const chunkX = Math.floor(x / chunkSize);
        const chunkZ = Math.floor(y / chunkSize);
        const localX = x - chunkX * chunkSize;
        const localY = y - chunkZ * chunkSize;
        const r = 0.18;
        const minX = Math.floor(localX - r), maxX = Math.floor(localX + r);
        const minY = Math.floor(localY - r), maxY = Math.floor(localY + r);
        for (let gy = minY; gy <= maxY; gy++) {
          for (let gx = minX; gx <= maxX; gx++) {
            if (isWallAt(gx, gy, chunkX, chunkZ)) {
              const closestX = Math.max(gx, Math.min(localX, gx + 1));
              const closestY = Math.max(gy, Math.min(localY, gy + 1));
              const dx = localX - closestX, dy = localY - closestY;
              if (dx*dx + dy*dy < r*r) return true;
            }
          }
        }
        return false;
      }

      const keys = {};
      window.addEventListener('keydown', e => {
        keys[e.key.toLowerCase()] = true;
        if (e.key === 'Escape') canvas.requestPointerLock?.(); // Release pointer lock to open console
      });
      window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

      generateChunk(0, 0);

      engine.runRenderLoop(() => {
        checkChunks();
        const speed = 5.0; // Faster movement
        const dt = Math.min(engine.getDeltaTime() / 1000, 0.016); // Cap delta time
        let dx = 0, dz = 0;
        if (keys['w']) dz -= speed * dt;
        if (keys['s']) dz += speed * dt;
        if (keys['a']) dx -= speed * dt;
        if (keys['d']) dx += speed * dt;

        const sin = Math.sin(camera.rotation.y), cos = Math.cos(camera.rotation.y);
        const nx = camera.position.x + dx * cos - dz * sin;
        const nz = camera.position.z + dx * sin + dz * cos;

        if (!collidesAt(nx, camera.position.z)) camera.position.x = nx;
        if (!collidesAt(camera.position.x, nz)) camera.position.z = nz;

        scene.render();
      });

      window.addEventListener('resize', () => engine.resize());
      console.log('[DEBUG] Optimized infinite maze with assets running.');
    })();
  </script>
</body>
</html>
