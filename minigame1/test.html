<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Haunted Maze â€” Infinite Maze</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body { margin: 0; height: 100%; background: #000; overflow: hidden; font-family: system-ui, sans-serif; color: #fff; }
    #babylon-canvas { width: 100vw; height: 100vh; display: block; }
  </style>
</head>
<body>
  <canvas id="babylon-canvas"></canvas>

  <!-- scripts -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script>
    // Infinite maze with 100x100 chunks
    (() => {
      console.log('[DEBUG] Initializing infinite maze...');
      const canvas = document.getElementById('babylon-canvas');
      const engine = new BABYLON.Engine(canvas, true);
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color3(0, 0, 0);

      const camera = new BABYLON.UniversalCamera("camera", new BABYLON.Vector3(50, 1.7, 50), scene);
      camera.setTarget(new BABYLON.Vector3(0, 0, 1));
      camera.attachControl(canvas, true);

      const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

      const chunkSize = 100;
      let chunks = {};
      let exitChunk = null;

      function generateChunk(chunkX, chunkZ) {
        const key = `${chunkX},${chunkZ}`;
        if (chunks[key]) return;
        console.log(`[DEBUG] Generating chunk at (${chunkX}, ${chunkZ})`);
        const cells = Array.from({length: chunkSize}, () => Array.from({length: chunkSize}, () => 1));
        function carve(x,y) {
          const dirs = [[1,0],[-1,0],[0,1],[0,-1]].sort(() => Math.random()-0.5);
          for (let [dx,dy] of dirs) {
            const nx = x+dx*2, ny=y+dy*2;
            if(ny>=0 && ny<chunkSize && nx>=0 && nx<chunkSize && cells[ny][nx]===1){
              cells[y+dy][x+dx]=0; cells[ny][nx]=0;
              carve(nx,ny);
            }
          }
        }
        cells[1][1]=0; carve(1,1);
        chunks[key] = { cells };

        if (!exitChunk && Math.random() < 0.1) {
          exitChunk = key;
          cells[chunkSize - 2][chunkSize - 2] = 2;
          console.log(`[DEBUG] Exit placed in chunk ${key}`);
        }

        const offsetX = chunkX * chunkSize;
        const offsetZ = chunkZ * chunkSize;
        for(let r=0;r<chunkSize;r++){
          for(let c=0;c<chunkSize;c++){
            if(cells[r][c]===1){
              const box = BABYLON.MeshBuilder.CreateBox("wall", {width:1, height:2.4, depth:1}, scene);
              box.position = new BABYLON.Vector3(offsetX + c + 0.5, 1.2, offsetZ + r + 0.5);
              const wallMat = new BABYLON.StandardMaterial("wallMat", scene);
              wallMat.diffuseColor = new BABYLON.Color3(0.13, 0.13, 0.13);
              box.material = wallMat;
            } else if(cells[r][c]===2){
              const exit = BABYLON.MeshBuilder.CreateBox("exit", {width:1, height:1, depth:1}, scene);
              exit.position = new BABYLON.Vector3(offsetX + c + 0.5, 0.5, offsetZ + r + 0.5);
              const exitMat = new BABYLON.StandardMaterial("exitMat", scene);
              exitMat.diffuseColor = new BABYLON.Color3(0, 1, 0);
              exit.material = exitMat;
            }
          }
        }
      }

      function checkChunks() {
        const chunkX = Math.floor(camera.position.x / chunkSize);
        const chunkZ = Math.floor(camera.position.z / chunkSize);
        for (let dx = -1; dx <= 1; dx++) {
          for (let dz = -1; dz <= 1; dz++) {
            generateChunk(chunkX + dx, chunkZ + dz);
          }
        }
      }

      function isWallAt(mx, my, chunkX, chunkZ) {
        const key = `${chunkX},${chunkZ}`;
        if (!chunks[key]) return true;
        const cells = chunks[key].cells;
        if (mx < 0 || my < 0 || mx >= chunkSize || my >= chunkSize) return true;
        return cells[Math.floor(my)][Math.floor(mx)] === 1;
      }
      function collidesAt(x, y) {
        const chunkX = Math.floor(x / chunkSize);
        const chunkZ = Math.floor(y / chunkSize);
        const localX = x - chunkX * chunkSize;
        const localY = y - chunkZ * chunkSize;
        const r = 0.18;
        const minX = Math.floor(localX - r), maxX = Math.floor(localX + r);
        const minY = Math.floor(localY - r), maxY = Math.floor(localY + r);
        for (let gy = minY; gy <= maxY; gy++) {
          for (let gx = minX; gx <= maxX; gx++) {
            if (isWallAt(gx, gy, chunkX, chunkZ)) {
              const closestX = Math.max(gx, Math.min(localX, gx + 1));
              const closestY = Math.max(gy, Math.min(localY, gy + 1));
              const dx = localX - closestX, dy = localY - closestY;
              if (dx*dx + dy*dy < r*r) return true;
            }
          }
        }
        return false;
      }

      const keys = {};
      window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
      window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

      generateChunk(0, 0);

      engine.runRenderLoop(() => {
        checkChunks();
        const speed = 3.2;
        const dt = engine.getDeltaTime() / 1000;
        let dx = 0, dz = 0;
        if (keys['w']) dz -= speed * dt;
        if (keys['s']) dz += speed * dt;
        if (keys['a']) dx -= speed * dt;
        if (keys['d']) dx += speed * dt;

        const sin = Math.sin(camera.rotation.y), cos = Math.cos(camera.rotation.y);
        const nx = camera.position.x + dx * cos - dz * sin;
        const nz = camera.position.z + dx * sin + dz * cos;

        if (!collidesAt(nx, camera.position.z)) camera.position.x = nx;
        if (!collidesAt(camera.position.x, nz)) camera.position.z = nz;

        scene.render();
      });

      window.addEventListener('resize', () => engine.resize());
      console.log('[DEBUG] Infinite maze running.');
    })();
  </script>
</body>
</html>
