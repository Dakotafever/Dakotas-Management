<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Haunted Maze â€” Web Minigame</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:system-ui,sans-serif;color:#fff}
#babylon-canvas{width:100vw;height:100vh;display:block}
#ui{position:absolute;inset:0;pointer-events:none;z-index:50}
.overlay{pointer-events:auto;position:absolute;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.75);padding:18px;border-radius:8px;max-width:820px;text-align:center}
#intro{top:18vh}
#message{top:30vh;display:none}
.hidden{display:none}
#jumpscare{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#000;z-index:2000;pointer-events:none;opacity:0;transition:opacity .25s ease}
#jumpscare.visible{opacity:1}
#jumpscare img{width:100%;height:100%;object-fit:cover}
#vhs{position:fixed;inset:0;pointer-events:none;z-index:900}
#scanlines{position:absolute;inset:0;background-image:linear-gradient(rgba(0,0,0,0.02) 50%, rgba(255,255,255,0.02) 51%);background-size:100% 2px;mix-blend-mode:overlay;opacity:.6}
button{background:#aa0000;color:#fff;border:none;padding:10px 14px;border-radius:6px;cursor:pointer;font-weight:600}
button:hover{filter:brightness(1.05)}
#debug-overlay{position:fixed;right:10px;top:10px;background:rgba(0,0,0,0.7);color:#fff;padding:8px;font-family:monospace;font-size:12px;z-index:1100;display:none;max-width:280px}
</style>
</head>
<body>

<canvas id="babylon-canvas"></canvas>

<div id="ui">
<div id="intro" class="overlay">
<h1 id="title">Haunted Maze</h1>
<p id="intro-text">Find the exit. Click Start, then click inside the maze to lock the mouse. WASD to move. Toggle VHS (V). Pause (P) exits to main page.</p>
<button id="startBtn">Start</button>
</div>

<div id="message" class="overlay hidden"></div>
</div>

<div id="jumpscare" aria-hidden="true"><img id="jumpscare-img" src="" alt="jumpscare"></div>

<div id="vhs" class="hidden"><div id="scanlines"></div></div>

<div id="debug-overlay" aria-hidden="true"></div>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script>

(async()=>{
// --- CONFIG ---
const CONFIG = {
  cols:40,
  rows:30,
  wallHeight:2.6,
  playerHeight:1.7,
  playerRadius:0.35,
  maxJumpscares:23,
  jumpscareDurationRange:[1500,2500],
  ambientIntervalMin:8000,
  ambientIntervalMax:25000,
  wallTexture:'assets/decor1.png',
  ceilingTexture:'assets/decor2.png',
  walldecorCount:8,
  jumpscareCount:6,
  ambientCount:8
};

// --- DOM ---
const canvas=document.getElementById('babylon-canvas');
const startBtn=document.getElementById('startBtn');
const intro=document.getElementById('intro');
const jumpscareEl=document.getElementById('jumpscare');
const jumpscareImg=document.getElementById('jumpscare-img');
const debugOverlay=document.getElementById('debug-overlay');
const nextJumpscare = Math.random()*5000 + 2000; // instead of very high random

// --- BABYLON SETUP ---
const engine=new BABYLON.Engine(canvas,true);
const scene=new BABYLON.Scene(engine);
scene.clearColor=new BABYLON.Color3(0,0,0);
scene.fogMode=BABYLON.Scene.FOGMODE_EXP2;
scene.fogDensity=0.05;
scene.collisionsEnabled = true;


const hemi=new BABYLON.HemisphericLight('h',new BABYLON.Vector3(0,1,0),scene);
hemi.intensity=0.6;
setInterval(()=>{hemi.intensity=0.5+Math.random()*0.4;},120);

const camera=new BABYLON.UniversalCamera('cam', new BABYLON.Vector3(1.5,CONFIG.playerHeight,1.5),scene);
camera.attachControl(canvas,true);
camera.checkCollisions = true;
camera.applyGravity = true;
camera.ellipsoid = new BABYLON.Vector3(CONFIG.playerRadius, CONFIG.playerHeight*0.5, CONFIG.playerRadius);
camera.ellipsoidOffset = new BABYLON.Vector3(0, CONFIG.playerHeight*0.5, 0);


canvas.addEventListener('click', () => {
    canvas.requestPointerLock = canvas.requestPointerLock 
        || canvas.msRequestPointerLock 
        || canvas.mozRequestPointerLock 
        || canvas.webkitRequestPointerLock;
    if (canvas.requestPointerLock) {
        canvas.requestPointerLock();
    }
});

document.addEventListener('pointerlockchange', () => {
    if (document.pointerLockElement === canvas) {
        camera.attachControl(canvas, true);  // enable mouse look
    } else {
        camera.detachControl(canvas);        // disable if pointer lost
    }
});



  
// --- UTILITY ---
function assetExists(url){return fetch(url,{method:'HEAD'}).then(r=>r.ok).catch(()=>false);}

// --- MAZE ---
const grid={cols:CONFIG.cols,rows:CONFIG.rows,cellSize:1,cells:[]};
function generateMaze(){
  const cols=grid.cols, rows=grid.rows;
  const cells=Array.from({length:rows}, ()=>Array.from({length:cols}, ()=>1));
  function carve(x,y){
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]].sort(()=>Math.random()-0.5);
    for(const [dx,dy] of dirs){
      const nx=x+dx*2, ny=y+dy*2;
      if(ny>=0 && ny<rows && nx>=0 && nx<cols && cells[ny][nx]===1){
        cells[y+dy][x+dx]=0; cells[ny][nx]=0; carve(nx,ny);
      }
    }
  }
  cells[1][1]=0; carve(1,1);
  grid.cells=cells;
}

// --- WORLD BUILD ---
let wallTexture, ceilingTexture;
async function buildWorld(){
  const floor=BABYLON.MeshBuilder.CreateGround('floor',{width:grid.cols,height:grid.rows},scene);
  floor.position=new BABYLON.Vector3(grid.cols/2,0,grid.rows/2);
  const floorMat=new BABYLON.StandardMaterial('floorMat',scene); floorMat.diffuseColor=new BABYLON.Color3(0.08,0.08,0.08); floor.material=floorMat;

  const ceiling=BABYLON.MeshBuilder.CreateGround('ceiling',{width:grid.cols,height:grid.rows},scene);
  ceiling.position=new BABYLON.Vector3(grid.cols/2,CONFIG.wallHeight,grid.rows/2);
  ceiling.rotation.x=Math.PI;
  try{ceilingTexture=new BABYLON.Texture(CONFIG.ceilingTexture,scene); ceilingTexture.uScale=grid.cols/4; ceilingTexture.vScale=grid.rows/4;}
  catch(e){ceilingTexture=null;}
  const ceilMat=new BABYLON.StandardMaterial('ceilMat',scene);
  if(ceilingTexture) ceilMat.diffuseTexture=ceilingTexture; else ceilMat.diffuseColor=new BABYLON.Color3(0.06,0.06,0.06);
  ceiling.material=ceilMat; ceiling.checkCollisions=true;

  const wallMat=new BABYLON.StandardMaterial('wallMat',scene);
  try{wallTexture=new BABYLON.Texture(CONFIG.wallTexture,scene); wallTexture.uScale=1; wallTexture.vScale=1; wallMat.diffuseTexture=wallTexture;}
  catch(e){wallMat.diffuseColor=new BABYLON.Color3(0.15,0.15,0.15);}
  const wallGroup=new BABYLON.TransformNode('walls',scene);
  for(let r=0;r<grid.rows;r++){
    for(let c=0;c<grid.cols;c++){
      if(grid.cells[r][c]===1){
        const box=BABYLON.MeshBuilder.CreateBox(`w_${r}_${c}`,{width:1,height:CONFIG.wallHeight,depth:1},scene);
        box.position=new BABYLON.Vector3(c+0.5,CONFIG.wallHeight/2,r+0.5);
        box.material=wallMat.clone(`wmat_${r}_${c}`);
        box.checkCollisions = true;
        box.parent=wallGroup;
      
if (Math.random() < 0.25) { // 25% chance
    const decorIndex = Math.floor(Math.random() * CONFIG.walldecorCount) + 1;
    const decorMat = new BABYLON.StandardMaterial(`decorMat${r}_${c}`, scene);
    decorMat.diffuseTexture = new BABYLON.Texture(`assets/walldecor${decorIndex}.png`, scene);
    decorMat.diffuseTexture.hasAlpha = true;

    const decorPlane = BABYLON.MeshBuilder.CreatePlane(`decor_${r}_${c}`, {width:1, height:1}, scene);
    decorPlane.material = decorMat;

    // Adjust position to face wall properly
    decorPlane.position = box.position.clone();
    decorPlane.position.y = 1.5;
    decorPlane.position.z += 0.51; // slightly off the wall
    decorPlane.parent = box;
}

     }
    }
  }
}

// --- EDITING MODE ---
let editCode="Editing6263", inputBuffer="", editingMode=false;
window.addEventListener('keydown', e=>{
  inputBuffer += e.key;
  if(inputBuffer.length>editCode.length) inputBuffer=inputBuffer.slice(-editCode.length);
  if(inputBuffer===editCode){
    editingMode=!editingMode;
    alert("Editing mode " + (editingMode ? "ON" : "OFF"));
    console.log("Editing mode:", editingMode);
  }
});

// --- COLLISION ---
function collidesAt(x,z){
  const r=CONFIG.playerRadius;
  const minX=Math.floor(x-r), maxX=Math.floor(x+r);
  const minY=Math.floor(z-r), maxY=Math.floor(z+r);
  for(let gy=minY;gy<=maxY;gy++){
    for(let gx=minX;gx<=maxX;gx++){
      if(gy<0||gx<0||gy>=grid.rows||gx>=grid.cols) return true;
      if(grid.cells[gy][gx]===1){
        const closestX=Math.max(gx, Math.min(x,gx+1));
        const closestY=Math.max(gy, Math.min(z,gy+1));
        const dx=x-closestX, dy=z-closestY;
        if(dx*dx+dy*dy<r*r) return true;
      }
    }
  }
  return false;
}

// --- PLAYER MODEL ---
async function tryLoadSkin() {
    const path = 'assets/skin.glb';
    if (await assetExists(path)) {
        try {
            BABYLON.SceneLoader.ImportMesh(
                '', 
                'assets/', 
                'skin.glb', 
                scene, 
                meshes => {
                    const root = new BABYLON.TransformNode('playerSkin', scene);
                    meshes.forEach(m => m.parent = root);
                    root.parent = camera;
                    root.position = new BABYLON.Vector3(0, -0.6, 0.6);
                    root.scaling = new BABYLON.Vector3(1, 1, 1);
                },
                null,
                (scene, message, exception) => {
                    console.error('Error loading skin:', message, exception);
                }
            );
        } catch (e) {
            console.error('Failed to load skin.glb:', e);
        }
    }
}


startBtn.addEventListener('click', async () => {
    intro.classList.add('hidden');
    document.body.focus();

    generateMaze();
    await buildWorld();
    await tryLoadSkin();
    
  
  await BABYLON.Engine.audioEngine.unlockAsync();


    // --- AMBIENT SOUNDS ---
const ambientSounds = [];
for (let i = 1; i <= CONFIG.ambientCount; i++) {
    const s = new BABYLON.Sound(
        `ambient${i}`, 
        `assets/ambient${i}.mp3`, 
        scene, 
        null, 
        { loop: false, volume: 0.35 }
    );
    ambientSounds.push(s);
}

function playRandomAmbient() {
    const sound = ambientSounds[Math.floor(Math.random() * ambientSounds.length)];
    sound.play();
    const next = CONFIG.ambientIntervalMin + Math.random() * (CONFIG.ambientIntervalMax - CONFIG.ambientIntervalMin);
    setTimeout(playRandomAmbient, next);
}

// call after Start button click
playRandomAmbient();

    engine.runRenderLoop(renderLoop);
  
function triggerJumpscare(){
    const index = Math.floor(Math.random() * CONFIG.jumpscareCount) + 1;
    jumpscareImg.src = `assets/jumpscare${index}.png`;

    const sound = new BABYLON.Sound(
        `jumpscare${index}`, 
        `assets/jumpscare${index}.mp3`, 
        scene, 
        null, 
        { volume: 1 }
    );
    sound.play();

    jumpscareEl.classList.add('visible');
    setTimeout(() => jumpscareEl.classList.remove('visible'),
        CONFIG.jumpscareDurationRange[0] + Math.random() * (CONFIG.jumpscareDurationRange[1]-CONFIG.jumpscareDurationRange[0])
    );
}

function scheduleJumpscares() {
    const delay = Math.random() * 7000 + 3000; // 3â€“10s between jumpscares
    setTimeout(() => {
        triggerJumpscare();
        scheduleJumpscares();
    }, delay);
}

// call after Start
scheduleJumpscares();
});
// --- INPUT ---
const keyState={};
window.addEventListener('keydown', e=>{
  keyState[e.key.toLowerCase()]=true;
  if(e.key==='v'||e.key==='V') document.getElementById('vhs').classList.toggle('hidden');
  if(e.key==='p'||e.key==='P') window.location.href='../devilsroulette.html';
});
window.addEventListener('keyup', e=>keyState[e.key.toLowerCase()]=false);

// --- RENDER LOOP ---
let last=performance.now();
function renderLoop(){
  const now=performance.now();
  const dt=Math.min(0.06,(now-last)/1000); last=now;

  let forwardInput=(keyState['w']?1:0)-(keyState['s']?1:0);
  let strafeInput=(keyState['d']?1:0)-(keyState['a']?1:0);
  const speed=4.2*dt;

  if(editingMode){
    if(keyState[' ']) camera.position.y += speed*4;
    if(keyState['shift']) camera.position.y -= speed*4;
  }

  if(forwardInput!==0 || strafeInput!==0){
    const forward=camera.getDirection(BABYLON.Axis.Z);
    const right=camera.getDirection(BABYLON.Axis.X);
    const disp=forward.scale(forwardInput*speed).add(right.scale(strafeInput*speed));
    const nx=camera.position.x+disp.x;
    const nz=camera.position.z+disp.z;

    if(editingMode){
      camera.position.x=nx; camera.position.z=nz;
    } else {
      if(!collidesAt(nx,camera.position.z)) camera.position.x=nx;
      if(!collidesAt(camera.position.x,nz)) camera.position.z=nz;
    }
  }

  scene.render();
}

// --- CLEANUP ---
window.addEventListener('beforeunload', ()=>{try{engine.stopRenderLoop();}catch(e){} engine.dispose();});

})();
</script>
</body>
</html>
