<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Haunted Maze â€” Web Minigame</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body { margin: 0; height: 100%; background: #000; overflow: hidden; font-family: system-ui, sans-serif; color: #fff; }
    #babylon-canvas { width: 100vw; height: 100vh; display: block; }
    #ui { position: absolute; inset: 0; pointer-events: none; z-index: 50; }
    .overlay { pointer-events: auto; position: absolute; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); padding: 18px; border-radius: 8px; max-width: 820px; text-align: center; }
    #intro { top: 18vh; }
    #message { top: 30vh; display: none; }
    .hidden { display: none; }
    #mini-wrap { position: absolute; right: 12px; top: 12px; border: 2px solid rgba(255,255,255,0.08); z-index: 60; pointer-events: auto; }
    #minimap { width: 260px; height: 200px; display: block; background: #222; }
    #jumpscare {
      position: fixed; inset: 0;
      display: flex; align-items: center; justify-content: center;
      background: black; z-index: 999; pointer-events: none;
      opacity: 0; transition: opacity 0.3s ease;
    }
    #jumpscare.visible { opacity: 1; }
    #jumpscare img { width: 100%; height: 100%; object-fit: cover; }
    #vhs { position: fixed; inset: 0; pointer-events: none; z-index: 900; }
    #vhs #scanlines { position: absolute; inset: 0; background-image: linear-gradient(rgba(0,0,0,0.02) 50%, rgba(255,255,255,0.02) 51%); background-size: 100% 2px; mix-blend-mode: overlay; opacity: 0.6; }
    button { background: #aa0000; color: white; border: none; padding: 10px 14px; border-radius: 6px; cursor: pointer; font-weight: 600; }
    button:hover { filter: brightness(1.05); }
  </style>
</head>
<body>

  <canvas id="babylon-canvas"></canvas>

  <div id="ui">
    <div id="intro" class="overlay">
      <h1 id="title">Haunted Maze</h1>
      <p id="intro-text">Find the exit. Click Start, then click inside the maze to lock the mouse. WASD to move. Toggle VHS (V). Toggle minimap (M).</p>
      <button id="startBtn">Start</button>
    </div>
    <div id="message" class="overlay hidden"></div>
    <div id="mini-wrap" class="hidden"><canvas id="minimap"></canvas></div>
  </div>

  <div id="jumpscare" class="hidden">
    <img id="jumpscare-img" src="" alt="scary image" />
  </div>

  <div id="vhs" class="hidden">
    <div id="scanlines"></div>
  </div>

  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script>
  (() => {
    const CONFIG = {
      cellPx: 8,
      wallHeight: 2.4,
      playerHeight: 1.7,
      playerRadius: 0.18,
      maxJumpscares: 6,
      jumpscareDurationRange: [2000, 3000],
      ambientIntervalMin: 8000,
      ambientIntervalMax: 25000,
      decorImages: ["assets/decor1.png", "assets/decor2.png"],
      jumpscareImages: [
        "assets/jumpscare1.png","assets/jumpscare2.png","assets/jumpscare3.png",
        "assets/jumpscare4.png","assets/jumpscare5.png","assets/jumpscare6.png"
      ],
      jumpscareAudios: [
        "assets/jumpscare1.mp3","assets/jumpscare2.mp3","assets/jumpscare3.mp3",
        "assets/jumpscare4.mp3","assets/jumpscare5.mp3","assets/jumpscare6.mp3"
      ]
    };

    // DOM refs
    const canvas = document.getElementById("babylon-canvas");
    const startBtn = document.getElementById("startBtn");
    const intro = document.getElementById("intro");
    const jumpscareEl = document.getElementById("jumpscare");
    const jumpscareImg = document.getElementById("jumpscare-img");
    const minimapWrap = document.getElementById("mini-wrap");
    const minimapCanvas = document.getElementById("minimap");
    const messageEl = document.getElementById("message");

    // Babylon setup
    const engine = new BABYLON.Engine(canvas, true);
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0, 0, 0);
    scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
    scene.fogDensity = 0.05;

    const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.6;

    // Flicker effect
    setInterval(() => { light.intensity = 0.5 + Math.random() * 0.3; }, 200);

    const camera = new BABYLON.UniversalCamera("camera", new BABYLON.Vector3(1.5, CONFIG.playerHeight, 1.5), scene);
    camera.attachControl(canvas, true);
    camera.speed = 0.08;

    // Build maze
    let grid = { cols: 40, rows: 30, cellSize: 1, cells: [] };

    async function buildMaze() {
      const cols = grid.cols, rows = grid.rows;
      const cells = Array.from({ length: rows }, () => Array.from({ length: cols }, () => 1));
      function carve(x, y) {
        const dirs = [[1,0],[-1,0],[0,1],[0,-1]].sort(() => Math.random() - 0.5);
        for (let [dx, dy] of dirs) {
          const nx = x + dx * 2, ny = y + dy * 2;
          if (ny >= 0 && ny < rows && nx >= 0 && nx < cols && cells[ny][nx] === 1) {
            cells[y + dy][x + dx] = 0; cells[ny][nx] = 0;
            carve(nx, ny);
          }
        }
      }
      cells[1][1] = 0; carve(1, 1);
      grid.cells = cells;

      const floor = BABYLON.MeshBuilder.CreateGround("floor", { width: cols, height: rows }, scene);
      floor.position = new BABYLON.Vector3(cols/2, 0, rows/2);
      const floorMat = new BABYLON.StandardMaterial("floorMat", scene);
      floorMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);
      floor.material = floorMat;

      // Ceiling
      const ceiling = BABYLON.MeshBuilder.CreateGround("ceiling", { width: cols, height: rows }, scene);
      ceiling.position = new BABYLON.Vector3(cols/2, CONFIG.wallHeight, rows/2);
      ceiling.rotation.x = Math.PI;
      const ceilMat = new BABYLON.StandardMaterial("ceilMat", scene);
      ceilMat.diffuseTexture = new BABYLON.Texture(CONFIG.decorImages[1], scene);
      ceiling.material = ceilMat;

      const wallTex = new BABYLON.Texture(CONFIG.decorImages[0], scene);
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (cells[r][c] === 1) {
            const wall = BABYLON.MeshBuilder.CreateBox("wall", { width: 1, height: CONFIG.wallHeight, depth: 1 }, scene);
            wall.position = new BABYLON.Vector3(c + 0.5, CONFIG.wallHeight / 2, r + 0.5);
            const mat = new BABYLON.StandardMaterial("wallMat", scene);
            mat.diffuseTexture = wallTex;
            wall.material = mat;
          }
        }
      }
    }

    // Minimap
    const mapCtx = minimapCanvas.getContext("2d");
    function drawMinimap() {
      minimapCanvas.width = grid.cols;
      minimapCanvas.height = grid.rows;
      for (let r = 0; r < grid.rows; r++) {
        for (let c = 0; c < grid.cols; c++) {
          mapCtx.fillStyle = grid.cells[r][c] === 1 ? "#222" : "#000";
          mapCtx.fillRect(c, r, 1, 1);
        }
      }
      mapCtx.fillStyle = "#f00";
      mapCtx.fillRect(Math.floor(camera.position.x), Math.floor(camera.position.z), 1, 1);
    }

    function toggleMinimap() {
      minimapWrap.classList.toggle("hidden");
    }

    // Pointer lock fix
    canvas.addEventListener("click", () => {
      canvas.requestPointerLock?.();
    });

    // Jumpscare logic
    let jumpscareCount = 0;
    function triggerJumpscare() {
      if (jumpscareCount >= CONFIG.maxJumpscares) return;
      jumpscareCount++;
      const idx = Math.floor(Math.random() * CONFIG.jumpscareImages.length);
      const imgPath = CONFIG.jumpscareImages[idx];
      const audioPath = CONFIG.jumpscareAudios[idx];

      jumpscareImg.src = imgPath;
      jumpscareEl.classList.remove("hidden");
      jumpscareEl.classList.add("visible");

      const audio = new Audio(audioPath);
      audio.volume = 1.0;
      audio.play().catch(()=>{});

      setTimeout(() => {
        // Fade out audio
        const fade = setInterval(() => {
          if (audio.volume > 0.05) audio.volume -= 0.05;
          else { clearInterval(fade); audio.pause(); }
        }, 200);

        jumpscareEl.classList.remove("visible");
        setTimeout(() => jumpscareEl.classList.add("hidden"), 300);
      }, CONFIG.jumpscareDurationRange[0] + Math.random() * (CONFIG.jumpscareDurationRange[1]-CONFIG.jumpscareDurationRange[0]));
    }

    // Controls
    const keys = {};
    window.addEventListener("keydown", e => {
      keys[e.key.toLowerCase()] = true;
      if (e.key === "m" || e.key === "M") toggleMinimap();
      if (e.key === "v" || e.key === "V") document.getElementById("vhs").classList.toggle("hidden");
    });
    window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

    function collidesAt(x, y) {
      const r = CONFIG.playerRadius;
      const minX = Math.floor(x - r), maxX = Math.floor(x + r);
      const minY = Math.floor(y - r), maxY = Math.floor(y + r);
      for (let gy = minY; gy <= maxY; gy++) {
        for (let gx = minX; gx <= maxX; gx++) {
          if (grid.cells[gy] && grid.cells[gy][gx] === 1) return true;
        }
      }
      return false;
    }

    // Start Game
    startBtn.addEventListener("click", async () => {
      intro.classList.add("hidden");
      await buildMaze();
      engine.runRenderLoop(() => {
        const dt = engine.getDeltaTime() / 1000;
        const speed = 3.5 * dt;
        let dx = 0, dz = 0;
        if (keys["w"]) dz -= speed;
        if (keys["s"]) dz += speed;
        if (keys["a"]) dx -= speed;
        if (keys["d"]) dx += speed;

        const sin = Math.sin(camera.rotation.y), cos = Math.cos(camera.rotation.y);
        const nx = camera.position.x + dx * cos - dz * sin;
        const nz = camera.position.z + dx * sin + dz * cos;

        if (!collidesAt(nx, camera.position.z)) camera.position.x = nx;
        if (!collidesAt(camera.position.x, nz)) camera.position.z = nz;

        if (Math.random() < 0.0008) triggerJumpscare();

        drawMinimap();
        scene.render();
      });
    });

    window.addEventListener("resize", () => engine.resize());
  })();
  </script>
</body>
</html>
